TOP ::= module IDENT = MEXPR
      | signature IDENT = MTYPE
      | fn IDENT[IDENT,+]?(IDENT : TYPE,*) -> TYPE { STAT;* }
      | type IDENT[IDENT,+]? = TYPE
      | type IDENT[IDENT,+]? { CONSDEF,* }
      | open MIDENT

CONSDEF ::= IDENT
          | IDENT(TYPE,*)
          | IDENT { IDENT : TYPE,* }

MIDENT ::= IDENT(MEXPR,*)?
         | MIDENT :: MIDENT

MEXPR ::= struct { TOP* }
        | functor (IDENT : MTYPE,*) { TOP* }
        | MIDENT
        | MEXPR <: MTYPE

QIDENT ::= MIDENT :: IDENT

MTYPE ::= sig { DECL* }
        | functor (IDENT : MTYPE,*) -> MTYPE
        | MIDENT

TYPE ::= QIDENT[TYPE,+]?
       | fn (TYPE,*) -> TYPE

DECL ::= fn IDENT[IDENT,+]?(IDENT : TYPE,*);
       | type IDENT[IDENT,+]? = TYPE
       | type IDENT[IDENT,+]? { CONSDEF,* }
       | type IDENT[IDENT,+]?

EXPR ::= LITERALS
       | QIDENT
       | EXPR(EXPR,*)
       | QIDENT { IDENT = EXPR,* }
       | EXPR.IDENT
       | ARITHMETIC OPS
       | ( EXPR )

STAT ::= let mut? PAT = EXPR  else STAT?
       | match EXPR { PAT => STAT,* }
       | if EXPR { STAT* } else { STAT* }
       | QIDENT(EXPR,*)
       | return EXPR
       | open MIDENT

PAT ::= QIDENT
      | QIDENT(PAT,*)
      | QIDENT { IDENT,* }
      | QIDENT { .. }
      | LITERAL
      | _
      | PAT | PAT
